Notes on vdiff
--------------

First it's important to note that there are two main ways to use vdiff: The diff+patch approach and the mutate approach. The former produces a list of diffs in one step, and then takes that patch and a target node and applies them. Since 0.7.x, Proactive uses mutate instead, where both steps are combined. The advantages are:
   * Less time building terms on the heap (the patch and vDOM are both often quite large and take time to write onto the heap when we call the patch step)
   * We don't need to accumulate the patch while working out the diffs. This means we can convert some recursive loops into backtrack-driven ones, saving heap space

The primary disadvantage is that you cannot batch together a series of patches and run them in a single animation frame.

The diff+patch mechanisms are still in the source, but may no longer work. reorder and reorder_1 are diff+patch, mutate_reorder and mutate_reorder_1 are mutate.


The general algorithm
---------------------

The idea is to generate a series of calls to patch_op/4 to transform one VDOM tree into another. We will call the two trees 'Left' (the old tree) and 'Right' (the new tree).
The React engine uses the virtual-dom Node.js package, which is obviously not written in Prolog. I've written something which is hopefully equivalent, and even more hopefully both *at least as* correct and fast *enough*. The problem is difficult to solve in general: Computing the actual mutation steps to go from Left to Right in a minimal way is, in general, far too time-consuming, so some compromises must be made.

The recursive algorithm is as follows:
   1) If Left is identical to Right, then stop.
   2) If Right is {null}, then the tree has been deleted. Simply delete the entire tree specified by Left, then stop.
   3) If Right is a leaf (widget or element) and Left is a leaf, then:
      3a) If they have different tags, then apply either a node_patch or widget_patch to convert Left into Right.
      3b) If they have the same tag, then apply a props_patch to make the attributes match (if necessary). Then do the reodering operation, outlined below. This will produce NewLeft, NewRight and optionally a reorder_patch. Proceed with the 'mutate children' process, outlined below as well.

Mutate children algorithm
-------------------------
This operation applies to two lists of VDOM nodes, generated by running the reordering operation (see below), and a list of DOM nodes corresponding (sort of) to the DOM nodes in NewLeft.

   1) If the head of NewLeft is {null} then we have a so-called 'tombstone'. If NewRight is not empty, then apply an insert_patch.
   2) If NewLeft contains any other item, it corresponds to the next DOM node in the list. If NewRight contains an item, run the general algorithm (above) on the head of NewLeft and NewRight, supplying the next DOM node as the target. This transforms Left -> Right.
   3) Remove the first node from NewLeft and NewRight. Remove the first DOM node unless NewLeft started with {null}. Continue processing.

Reordering algorithm
--------------------
This is an algorithm that takes two lists of VDOM nodes (Left, Right) and produces 2 new lists (NewLeft, NewRight) and an optional reordering patch. The new children have these properties:
   * Children with the same key appear in the same place in both lists
   * Either list may contain {null} arbitrarily many times.
   * The order of elements in Left and NewLeft is preserved (that is, deleting all the {null} elements from NewLeft will always give you Left)
   * Removing the nulls from NewRight and applying the reordering patch will generate Right

In the diff+patch algorithm (as opposed to the mutate algorithm), the only place we would insert new elements was at the end of the list of children. This is because we didn't have a handle to the sibling DOM node at the time we were making the patch (the diff step) - that was only available when *applying* the patch in the next step. In the mutate algorithm though, we have both pieces of information, so we have a new operation: insert_at. This lets us skip a complicated reordering process and simplifies reorder quite a bit, but it means that the code is no longer compatible with both versions.

Some examples:
1:       [a,b,c]        -> [d,a,b,c]
becomes: [{null},a,b,c] -> [d,a,b,c] : No shuffles

2:       [a,b,c]        -> [a,b,c,d]
becomes: [a,b,c,{null}] -> [a,b,c,d] : No shuffles

3:       [a,b,c,d]      -> [a,c,b,d]
becomes: [a,b,c,d]      -> [a,b,c,d] : {remove c from index 2, insert c at index 1}

Case 3 is tricky to implement. If we process the list one item at a time, then after accepting 'a', we may decide to move c from position 2 and insert at position 1. But after that, we have something like [c,d] still on the left and [b,d] still on the right. This is not correct - we should instead consider the right to be [c,d] or the left to be [b,d]. To handle this we have to keep track of which elements we have already moved and handle them differently once we actually see them in their original location.

Actual algorithm:
1) If the keys match, consume both of them from the inputs and write them to the outputs
2) If the next left key doesnt appear in the right list, then put {null} (a tombstone - the node has been deleted) in the right list and continue with the next left key. Leave the right list alone. See example 1 above. If we did not include this step then we might get {remove a from 1, insert at 2, remove b from 2, insert at 3, ....}. For long lists, this quickly becomes very expensive.
3) If the next right key doesnt appear in the left list, then put {null} in the left list and continue with the next right key. Leave the left list alone.
4) If the next key on the right has already been removed, then just output the key on the left for both new lists and continue, since we have already moved this key to the right place.
5) Otherwise, the key has moved. Our options are to accept that the left key is in the final place and move the right one, or accept that the right key is in the final place and move the left one. Naively, we assume that we will move the right key (a more optimal algorithm may exist). Add the right key to the list of already-moved items. Do not consume the left key - we will try again in a moment.
