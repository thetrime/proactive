Notes on vdiff
--------------

First it's important to note that there are two main ways to use vdiff: The diff+patch approach and the mutate approach. The former produces a list of diffs in one step, and then takes that patch and a target node and applies them. Since 0.7.x, Proactive uses mutate instead, where both steps are combined. The advantages are:
   * Less time building terms on the heap (the patch and vDOM are both often quite large and take time to write onto the heap when we call the patch step)
   * We don't need to accumulate the patch while working out the diffs. This means we can convert some recursive loops into backtrack-driven ones, saving heap space

The primary disadvantage is that you cannot batch together a series of patches and run them in a single animation frame.

The diff+patch mechanisms are still in the source, but may no longer work.


The general algorithm
---------------------

The idea is to generate a series of calls to patch_op/4 to transform one VDOM tree into another. We will call the two trees 'Left' (the old tree) and 'Right' (the new tree).
The React engine uses the virtual-dom Node.js package, which is obviously not written in Prolog. I've written something which is hopefully equivalent, and even more hopefully both *at least as* correct and fast *enough*. The problem is difficult to solve in general: Computing the actual mutation steps to go from Left to Right in a minimal way is, in general, far too time-consuming, so some compromises must be made.

The recursive algorithm is as follows:
   1) If Left is identical to Right, then stop.
   2) If Right is {null}, then the tree has been deleted. Simply delete the entire tree specified by Left, then stop.
   3) If Right is a leaf (widget or element) and Left is a leaf, then:
      3a) If they have different tags, then apply either a node_patch or widget_patch to convert Left into Right.
      3b) If they have the same tag, then apply a props_patch to make the attributes match (if necessary). Then do the reodering operation, outlined below. This will produce NewLeft, NewRight and optionally a reorder_patch. Proceed with the 'mutate children' process, outlined below as well.

Mutate children algorithm
-------------------------
This operation applies to two lists of VDOM nodes, generated by running the reordering operation (see below), and a list of DOM nodes corresponding (sort of) to the DOM nodes in NewLeft.

   1) If the head of NewLeft is {null} then we have a tombstone. If NewRight is not empty, then apply an insert_patch.
   2) If NewLeft contains any other item, it corresponds to the next DOM node in the list. If NewRight contains an item, run the general algorithm (above) on the head of NewLeft and NewRight, supplying the next DOM node as the target.
   3) Remove the first node from NewLeft and NewRight. Remove the first DOM node unless NewLeft started with {null}. Continue processing.

Reordering algorithm
--------------------
This is an algorithm that takes two lists of VDOM nodes (Left, Right) and produces 2 new lists (NewLeft, NewRight) and an optional reordering patch. The new children have these properties:
   * Children with the same key appear in the same place in both lists
   * Either list may contain {null} arbitrarily many times.
   * Applying the reordering patch to NewRight and removing the nulls will generate Right (CHECKME: Is that even right?)

In the diff+patch algorithm (as opposed to the mutate algorithm), the only place we would insert new elements was at the end of the list of children. This is because we didn't have a handle to the sibling DOM node at the time we were making the patch (the diff step) - that was only available when *applying* the patch in the next step. In the mutate algorithm though, we have both pieces of information, so we have a new operation: insert_at. This lets us skip a complicated reordering process and simplifies reorder quite a bit, but it means that the code is no longer compatible with both versions.
